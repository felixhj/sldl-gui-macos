#!/usr/bin/env python3
"""
SoulseekDownloader - A Python GUI application for batch downloading music from Soulseek
using YouTube playlist URLs and the slsk-batchdl tool.
"""

import tkinter as tk
from tkinter import ttk, scrolledtext, filedialog, messagebox
import subprocess
import threading
import os
import sys
import glob
import json
import base64
import queue
from pathlib import Path
from typing import List, Dict, Any
from csv_processor import SLDLCSVProcessor


class SoulseekDownloader:
    def __init__(self, root):
        self.root = root
        self.root.title("Soulseek Downloader")
        self.root.geometry("1200x900")
        self.root.resizable(True, True)
        self.root.minsize(1000, 800)

        # Modern color palette
        self.colors = {
            'primary': '#1a365d',      # Dark blue
            'primary_light': '#2d3748', # Lighter dark blue
            'secondary': '#4299e1',     # Blue
            'accent': '#38b2ac',        # Teal
            'success': '#38a169',       # Green
            'warning': '#ed8936',       # Orange
            'danger': '#e53e3e',        # Red
            'bg_primary': '#ffffff',    # White
            'bg_secondary': '#f7fafc',  # Light gray
            'bg_tertiary': '#edf2f7',   # Gray
            'text_primary': '#1a202c',  # Dark gray
            'text_secondary': '#4a5568', # Medium gray
            'text_muted': '#718096',    # Light gray
            'border': '#e2e8f0'         # Border gray
        }

        # Configure modern styling
        self.style = ttk.Style()
        self.style.theme_use('clam')
        self.setup_modern_styles()

        # Set background color
        self.root.configure(bg=self.colors['bg_secondary'])

        # Create main container with padding
        main_container = tk.Frame(root, bg=self.colors['bg_secondary'])
        main_container.pack(fill=tk.BOTH, expand=True, padx=30, pady=20)

        # Create scrollable main frame
        canvas = tk.Canvas(main_container, bg=self.colors['bg_secondary'], highlightthickness=0)
        scrollbar = ttk.Scrollbar(main_container, orient="vertical", command=canvas.yview)
        self.scrollable_frame = tk.Frame(canvas, bg=self.colors['bg_secondary'])

        self.scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )

        canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)

        # Pack canvas and scrollbar
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")

        # Main content
        self.create_header()
        self.create_connection_section()
        self.create_quality_section()
        self.create_action_section()
        self.create_progress_section()
        self.create_output_section()

        # Thread-safe GUI updates (must be set up before any safe_* method calls)
        self.gui_queue = queue.Queue()
        self.setup_gui_updates()

        # Initialize
        self.check_sldl_availability()
        self.csv_processor = SLDLCSVProcessor()

        # Settings management
        self.settings_file = Path.home() / ".soulseek_downloader_settings.json"
        self.loading_settings = True  # Flag to prevent saving during initial load
        self.load_settings()
        self.loading_settings = False  # Enable auto-saving after initial load

        # Bind mousewheel to canvas
        def _on_mousewheel(event):
            canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        canvas.bind_all("<MouseWheel>", _on_mousewheel)

        # Save settings when window is closed
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)

    def get_font(self, font_family, size, weight='normal'):
        """Get font with fallbacks for cross-platform compatibility"""
        # Font fallbacks: SF Pro -> Segoe UI -> Helvetica -> Arial -> System default
        font_families = {
            'SF Pro Display': ['SF Pro Display', 'Segoe UI', 'Helvetica Neue', 'Helvetica', 'Arial', 'sans-serif'],
            'SF Pro Text': ['SF Pro Text', 'Segoe UI', 'Helvetica Neue', 'Helvetica', 'Arial', 'sans-serif'],
            'SF Mono': ['SF Mono', 'Consolas', 'Monaco', 'Menlo', 'Courier New', 'monospace']
        }

        fallbacks = font_families.get(font_family, [font_family])

        for font in fallbacks:
            try:
                if weight == 'bold':
                    return (font, size, 'bold')
                else:
                    return (font, size)
            except:
                continue

        # Ultimate fallback
        return ('TkDefaultFont', size)

    def setup_modern_styles(self):
        """Configure modern ttk styles"""
        # Configure general styles
        self.style.configure('Modern.TFrame',
                           background=self.colors['bg_primary'],
                           relief='flat',
                           borderwidth=1)

        self.style.configure('Card.TFrame',
                           background=self.colors['bg_primary'],
                           relief='solid',
                           borderwidth=1)

        self.style.configure('Header.TLabel',
                           background=self.colors['bg_secondary'],
                           foreground=self.colors['text_primary'],
                           font=self.get_font('SF Pro Display', 28, 'bold'))

        self.style.configure('Subheader.TLabel',
                           background=self.colors['bg_primary'],
                           foreground=self.colors['text_primary'],
                           font=self.get_font('SF Pro Display', 16, 'bold'))

        self.style.configure('Body.TLabel',
                           background=self.colors['bg_primary'],
                           foreground=self.colors['text_secondary'],
                           font=self.get_font('SF Pro Text', 12))

        self.style.configure('Caption.TLabel',
                           background=self.colors['bg_primary'],
                           foreground=self.colors['text_muted'],
                           font=self.get_font('SF Pro Text', 10))

        # Modern button styles
        self.style.configure('Primary.TButton',
                           font=self.get_font('SF Pro Text', 12, 'bold'),
                           foreground='white',
                           background=self.colors['primary'],
                           borderwidth=0,
                           padding=(20, 12))

        self.style.map('Primary.TButton',
                      background=[('active', self.colors['primary_light']),
                                ('pressed', self.colors['primary'])])

        self.style.configure('Secondary.TButton',
                           font=self.get_font('SF Pro Text', 12),
                           foreground=self.colors['text_primary'],
                           background=self.colors['bg_tertiary'],
                           borderwidth=1,
                           padding=(16, 10))

        self.style.map('Secondary.TButton',
                      background=[('active', self.colors['border']),
                                ('pressed', self.colors['bg_tertiary'])])

        # Modern entry styles
        self.style.configure('Modern.TEntry',
                           font=self.get_font('SF Pro Text', 12),
                           padding=(12, 8),
                           borderwidth=1,
                           relief='solid')

        self.style.configure('Modern.TCombobox',
                           font=self.get_font('SF Pro Text', 12),
                           padding=(8, 6))

        # Modern labelframe
        self.style.configure('Modern.TLabelframe',
                           background=self.colors['bg_primary'],
                           borderwidth=0,
                           relief='flat')

        self.style.configure('Modern.TLabelframe.Label',
                           background=self.colors['bg_primary'],
                           foreground=self.colors['text_primary'],
                           font=self.get_font('SF Pro Display', 14, 'bold'))

        # Modern progressbar
        self.style.configure('Modern.Horizontal.TProgressbar',
                           background=self.colors['secondary'],
                           troughcolor=self.colors['bg_tertiary'],
                           borderwidth=0,
                           lightcolor=self.colors['secondary'],
                           darkcolor=self.colors['secondary'])

        self.style.configure('Modern.TProgressbar',
                           background=self.colors['secondary'],
                           troughcolor=self.colors['bg_tertiary'],
                           borderwidth=0,
                           lightcolor=self.colors['secondary'],
                           darkcolor=self.colors['secondary'])

        # Modern checkbutton
        self.style.configure('Modern.TCheckbutton',
                           background=self.colors['bg_primary'],
                           foreground=self.colors['text_secondary'],
                           font=self.get_font('SF Pro Text', 11),
                           focuscolor='none')

        self.style.map('Modern.TCheckbutton',
                      background=[('active', self.colors['bg_primary']),
                                ('pressed', self.colors['bg_primary'])])

    def create_header(self):
        """Create the application header"""
        header_frame = tk.Frame(self.scrollable_frame, bg=self.colors['bg_secondary'])
        header_frame.pack(fill=tk.X, pady=(0, 30))

        # Main title
        title_label = ttk.Label(header_frame, text="Soulseek Downloader", style='Header.TLabel')
        title_label.pack(anchor='w')

        # Subtitle
        subtitle_label = ttk.Label(header_frame,
                                 text="Download music collections from YouTube playlists via Soulseek",
                                 style='Body.TLabel')
        subtitle_label.configure(background=self.colors['bg_secondary'])
        subtitle_label.pack(anchor='w', pady=(5, 0))

    def create_connection_section(self):
        """Create the connection settings section"""
        # Section container
        section_frame = self.create_card_section("Connection Settings",
                                                "Configure your Soulseek credentials and download preferences")

        # Content grid
        content_frame = tk.Frame(section_frame, bg=self.colors['bg_primary'])
        content_frame.pack(fill=tk.X, padx=25, pady=(0, 25))

        # YouTube URL
        self.create_input_field(content_frame, "YouTube Playlist URL", 0, span=2, placeholder="https://www.youtube.com/playlist?list=...")
        self.playlist_url = self.last_entry
        self.playlist_url_var = self.last_var

        # Credentials row (YouTube URL takes rows 0-1, so credentials start at row 2)
        cred_frame = tk.Frame(content_frame, bg=self.colors['bg_primary'])
        cred_frame.grid(row=2, column=0, columnspan=2, sticky='ew', pady=(15, 0))
        cred_frame.columnconfigure(0, weight=1)
        cred_frame.columnconfigure(1, weight=1)

        # Username
        username_frame = tk.Frame(cred_frame, bg=self.colors['bg_primary'])
        username_frame.grid(row=0, column=0, sticky='ew', padx=(0, 10))
        self.create_input_field(username_frame, "Soulseek Username", 0)
        self.username = self.last_entry
        self.username_var = self.last_var
        self.username_var.trace('w', lambda *args: self.save_settings())

        # Password
        password_frame = tk.Frame(cred_frame, bg=self.colors['bg_primary'])
        password_frame.grid(row=0, column=1, sticky='ew', padx=(10, 0))
        self.create_input_field(password_frame, "Soulseek Password", 0, show="*")
        self.password = self.last_entry
        self.password_var = self.last_var
        self.password_var.trace('w', lambda *args: self.save_settings())

        # Password persistence checkbox (below both credential fields)
        checkbox_frame = tk.Frame(content_frame, bg=self.colors['bg_primary'])
        checkbox_frame.grid(row=3, column=0, columnspan=2, sticky='w', pady=(10, 0))

        self.remember_password_var = tk.BooleanVar()
        self.remember_password_var.set(True)  # Default to remembering password
        remember_cb = ttk.Checkbutton(checkbox_frame, text="Remember password",
                                    variable=self.remember_password_var,
                                    style='Modern.TCheckbutton')
        remember_cb.pack(anchor='w')
        self.remember_password_var.trace('w', lambda *args: self.on_remember_password_changed())

        # Download path (credentials are at row 2, checkbox at row 3, so path starts at row 4)
        path_frame = tk.Frame(content_frame, bg=self.colors['bg_primary'])
        path_frame.grid(row=4, column=0, columnspan=2, sticky='ew', pady=(15, 0))
        path_frame.columnconfigure(0, weight=1)

        self.create_input_field(path_frame, "Download Path (optional)", 0)
        self.download_path = self.last_entry
        self.download_path_var = self.last_var
        self.download_path_var.trace('w', lambda *args: self.save_settings())

        # Browse button - aligned with input field
        self.browse_btn = ttk.Button(path_frame, text="Browse", command=self.browse_directory, style='Secondary.TButton')
        self.browse_btn.grid(row=1, column=1, padx=(15, 0), pady=(0, 15), sticky='w')

    def create_quality_section(self):
        """Create the quality settings section"""
        section_frame = self.create_card_section("Audio Quality Settings",
                                                "Set preferred and required audio quality parameters")

        # Quality content
        quality_frame = tk.Frame(section_frame, bg=self.colors['bg_primary'])
        quality_frame.pack(fill=tk.X, padx=25, pady=(0, 25))
        quality_frame.columnconfigure(0, weight=1)
        quality_frame.columnconfigure(1, weight=1)

        # Preferred settings (left)
        pref_card = self.create_sub_card(quality_frame, "Preferred Settings",
                                       "Flexible options - will accept alternatives if not found")
        pref_card.grid(row=0, column=0, sticky='nsew', padx=(0, 10))

        pref_content = tk.Frame(pref_card, bg=self.colors['bg_primary'])
        pref_content.pack(fill=tk.X, padx=20, pady=(0, 20))

        self.create_quality_inputs(pref_content, "pref")

        # Strict settings (right)
        strict_card = self.create_sub_card(quality_frame, "Strict Requirements",
                                         "Required parameters - no alternatives accepted")
        strict_card.grid(row=0, column=1, sticky='nsew', padx=(10, 0))

        strict_content = tk.Frame(strict_card, bg=self.colors['bg_primary'])
        strict_content.pack(fill=tk.X, padx=20, pady=(0, 20))

        self.create_quality_inputs(strict_content, "strict")

    def create_quality_inputs(self, parent, prefix):
        """Create quality input fields"""
        # Format
        self.create_input_field(parent, "Format", 0, input_type="combobox",
                               values=["", "mp3", "flac", "wav", "m4a", "ogg"])
        setattr(self, f"{prefix}_format_var", self.last_var)
        self.last_var.trace('w', lambda *args: self.save_settings())

        # Min Bitrate
        self.create_input_field(parent, "Min Bitrate", 1, placeholder="e.g., 320")
        setattr(self, f"{prefix}_min_bitrate_var", self.last_var)
        self.last_var.trace('w', lambda *args: self.save_settings())

        # Max Bitrate
        self.create_input_field(parent, "Max Bitrate", 2, placeholder="e.g., 2500")
        setattr(self, f"{prefix}_max_bitrate_var", self.last_var)
        self.last_var.trace('w', lambda *args: self.save_settings())

    def create_action_section(self):
        """Create the action buttons section"""
        action_frame = tk.Frame(self.scrollable_frame, bg=self.colors['bg_secondary'])
        action_frame.pack(fill=tk.X, pady=20)

        # Center the buttons
        button_frame = tk.Frame(action_frame, bg=self.colors['bg_secondary'])
        button_frame.pack()

        # Download button
        self.download_btn = ttk.Button(button_frame, text="Start Download",
                                     command=self.start_download, style='Primary.TButton')
        self.download_btn.pack(side=tk.LEFT, padx=(0, 15))



    def create_progress_section(self):
        """Create the progress indicator section"""
        progress_frame = tk.Frame(self.scrollable_frame, bg=self.colors['bg_secondary'])
        progress_frame.pack(fill=tk.X, pady=(0, 20))

        # Progress label
        self.progress_label = ttk.Label(progress_frame, text="Ready to download", style='Body.TLabel')
        self.progress_label.configure(background=self.colors['bg_secondary'])
        self.progress_label.pack(anchor='w', pady=(0, 8))

        # Initialize status variable (used internally for status tracking)
        self.status_var = tk.StringVar()
        self.status_var.set("Ready")

        # Progress bar
        self.progress = ttk.Progressbar(progress_frame, length=400, mode='determinate', style='Modern.Horizontal.TProgressbar')
        self.progress.pack(fill=tk.X)
        # Initialize progress bar values
        self.progress['maximum'] = 100
        self.progress['value'] = 0

    def create_output_section(self):
        """Create the output log section"""
        section_frame = self.create_card_section("Download Log",
                                                "Real-time output from the download process")

        # Output text area with modern styling
        output_frame = tk.Frame(section_frame, bg=self.colors['bg_primary'])
        output_frame.pack(fill=tk.BOTH, expand=True, padx=25, pady=(0, 25))

        self.output = scrolledtext.ScrolledText(
            output_frame,
            height=12,
            width=80,
            font=self.get_font('SF Mono', 11),
            bg='#1a1a1a',
            fg='#e0e0e0',
            insertbackground='#ffffff',
            selectbackground='#404040',
            relief=tk.FLAT,
            borderwidth=0,
            padx=15,
            pady=15
        )
        self.output.pack(fill=tk.BOTH, expand=True)

    def ensure_determinate_mode(self):
        """Ensure progress bar is in determinate mode for showing actual progress"""
        try:
            current_mode = str(self.progress.cget('mode'))
            if current_mode == 'indeterminate':
                self.safe_log_output(f"[DEBUG] Switching from indeterminate to determinate mode\n")
                self.progress.stop()
                self.progress.config(mode='determinate')
        except Exception as e:
            self.safe_log_output(f"[DEBUG] Error checking progress mode: {e}\n")

    def update_progress(self, current, total, description=""):
        """Update progress bar with current/total values and log for debugging"""
        # This method is deprecated - use safe_update_progress instead
        self.safe_update_progress(current, total, description)

    def log_output(self, message):
        """Add message to output area"""
        # This method is deprecated - use safe_log_output instead
        self.safe_log_output(message)

    def create_card_section(self, title, description):
        """Create a card-style section with title and description"""
        # Main section frame
        section_frame = tk.Frame(self.scrollable_frame, bg=self.colors['bg_secondary'])
        section_frame.pack(fill=tk.X, pady=(0, 25))

        # Card frame
        card_frame = tk.Frame(section_frame, bg=self.colors['bg_primary'], relief='solid', bd=1)
        card_frame.pack(fill=tk.X)

        # Header
        header_frame = tk.Frame(card_frame, bg=self.colors['bg_primary'])
        header_frame.pack(fill=tk.X, padx=25, pady=25)

        # Title
        title_label = ttk.Label(header_frame, text=title, style='Subheader.TLabel')
        title_label.pack(anchor='w')

        # Description
        desc_label = ttk.Label(header_frame, text=description, style='Caption.TLabel')
        desc_label.pack(anchor='w', pady=(5, 0))

        return card_frame

    def create_sub_card(self, parent, title, description):
        """Create a sub-card within a section"""
        card = tk.Frame(parent, bg=self.colors['bg_tertiary'], relief='solid', bd=1)

        # Header
        header = tk.Frame(card, bg=self.colors['bg_tertiary'])
        header.pack(fill=tk.X, padx=20, pady=(20, 10))

        title_label = ttk.Label(header, text=title, style='Body.TLabel')
        title_label.configure(background=self.colors['bg_tertiary'], font=self.get_font('SF Pro Text', 12, 'bold'))
        title_label.pack(anchor='w')

        desc_label = ttk.Label(header, text=description, style='Caption.TLabel')
        desc_label.configure(background=self.colors['bg_tertiary'])
        desc_label.pack(anchor='w', pady=(2, 0))

        return card

    def create_input_field(self, parent, label, row, span=1, input_type="entry", show=None, values=None, placeholder=""):
        """Create a modern input field with label"""
        parent.columnconfigure(0, weight=1)

        # Label
        label_widget = ttk.Label(parent, text=label, style='Body.TLabel')
        label_widget.grid(row=row*2, column=0, columnspan=span, sticky='w', pady=(0, 8))

        # Input
        if input_type == "combobox":
            var = tk.StringVar()
            widget = ttk.Combobox(parent, textvariable=var, values=values or [], style='Modern.TCombobox', state="readonly")
            self.last_var = var
        else:
            var = tk.StringVar()
            widget = ttk.Entry(parent, textvariable=var, style='Modern.TEntry', show=show)
            if placeholder:
                widget.insert(0, placeholder)
                widget.configure(foreground=self.colors['text_muted'])

                def on_focus_in(event):
                    if widget.get() == placeholder:
                        widget.delete(0, tk.END)
                        widget.configure(foreground=self.colors['text_primary'])

                def on_focus_out(event):
                    if not widget.get():
                        widget.insert(0, placeholder)
                        widget.configure(foreground=self.colors['text_muted'])

                widget.bind('<FocusIn>', on_focus_in)
                widget.bind('<FocusOut>', on_focus_out)

            self.last_var = var

        widget.grid(row=row*2+1, column=0, columnspan=span, sticky='ew', pady=(0, 15))
        self.last_entry = widget

    def check_sldl_availability(self):
        """Check if sldl is available in the system PATH"""
        try:
            result = subprocess.run(['which', 'sldl'], capture_output=True, text=True)
            if result.returncode != 0:
                self.safe_log_output("Warning: sldl not found in PATH. Please ensure it's installed at /usr/local/bin/sldl\n")
                self.safe_update_status("Warning: sldl not found")
            else:
                self.safe_log_output(f"sldl found at: {result.stdout.strip()}\n")
                self.safe_update_status("Ready - sldl available")
        except Exception as e:
            self.safe_log_output(f"Error checking sldl availability: {e}\n")

    def browse_directory(self):
        """Open directory browser for download path"""
        directory = filedialog.askdirectory()
        if directory:
            self.download_path_var.set(directory)

    def on_remember_password_changed(self):
        """Handle changes to the remember password checkbox"""
        if not self.remember_password_var.get():
            # If unchecked, clear any saved password from settings file
            try:
                if self.settings_file.exists():
                    with open(self.settings_file, 'r') as f:
                        settings = json.load(f)

                    # Remove password from settings if it exists
                    if 'password' in settings:
                        del settings['password']

                    # Update remember_password setting
                    settings['remember_password'] = False

                    with open(self.settings_file, 'w') as f:
                        json.dump(settings, f, indent=2)
            except Exception as e:
                self.safe_log_output(f"Error updating password settings: {e}\n")

        # Save all settings to update the remember_password state
        self.save_settings()

    def log_output(self, message):
        """Add message to output area"""
        self.output.insert(tk.END, message)
        self.output.see(tk.END)
        self.root.update_idletasks()

    def start_download(self):
        """Start the download process in a separate thread"""
        # Get values from StringVars, handling placeholders
        playlist_url = self.playlist_url_var.get().strip()
        username_val = self.username_var.get().strip()
        password_val = self.password_var.get().strip()

        # Check for placeholders in entries
        if not playlist_url or playlist_url.startswith("https://www.youtube.com/playlist?list=..."):
            messagebox.showerror("Error", "Please enter a YouTube playlist URL")
            return

        if not username_val:
            messagebox.showerror("Error", "Please enter your Soulseek username")
            return

        if not password_val:
            messagebox.showerror("Error", "Please enter your Soulseek password")
            return

        # Run download in separate thread to keep GUI responsive
        thread = threading.Thread(target=self.download_songs, daemon=True)
        thread.start()

    def download_songs(self):
        """Execute the sldl command and capture output"""
        self.download_btn.config(state='disabled')
        self.browse_btn.config(state='disabled')
        self.progress['value'] = 0
        self.progress['maximum'] = 100
        self.safe_update_status("Starting download...")
        self.safe_gui_update(lambda: self.progress_label.config(text="Initializing download..."))
        self.safe_gui_update(lambda: self.output.delete(1.0, tk.END))

        # Force GUI update to show initial status
        self.safe_gui_update(lambda: None)  # Just trigger update processing

        try:
            # Build command - get values, filtering out placeholders
            playlist_url = self.playlist_url_var.get().strip()
            username_val = self.username_var.get().strip()
            password_val = self.password_var.get().strip()
            download_path_val = self.download_path_var.get().strip()

            cmd = ['sldl', playlist_url]

            # Add credentials
            cmd.extend(['--user', username_val])
            cmd.extend(['--pass', password_val])

            # Add download path if specified and not placeholder
            if download_path_val and not download_path_val.startswith("e.g.,"):
                cmd.extend(['--path', download_path_val])

            # Add preferred quality options (only if not empty and not placeholder)
            pref_format = self.pref_format_var.get().strip()
            if pref_format:
                cmd.extend(['--pref-format', pref_format])

            pref_min_br = self.pref_min_bitrate_var.get().strip()
            if pref_min_br and not pref_min_br.startswith("e.g.,"):
                cmd.extend(['--pref-min-bitrate', pref_min_br])

            pref_max_br = self.pref_max_bitrate_var.get().strip()
            if pref_max_br and not pref_max_br.startswith("e.g.,"):
                cmd.extend(['--pref-max-bitrate', pref_max_br])

            # Add strict quality options (only if not empty and not placeholder)
            strict_format = self.strict_format_var.get().strip()
            if strict_format:
                cmd.extend(['--format', strict_format])

            strict_min_br = self.strict_min_bitrate_var.get().strip()
            if strict_min_br and not strict_min_br.startswith("e.g.,"):
                cmd.extend(['--min-bitrate', strict_min_br])

            strict_max_br = self.strict_max_bitrate_var.get().strip()
            if strict_max_br and not strict_max_br.startswith("e.g.,"):
                cmd.extend(['--max-bitrate', strict_max_br])

            self.safe_log_output(f"Executing command: {' '.join(cmd[:3])} [password] {' '.join(cmd[4:])}\n")
            self.safe_log_output("-" * 50 + "\n")
            self.safe_update_status("Connecting to Soulseek...")
            self.safe_gui_update(lambda: self.progress_label.config(text="Connecting to Soulseek..."))

            # Run the process
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                bufsize=1,
                universal_newlines=True
            )

            self.safe_update_status("Processing playlist...")
            self.safe_gui_update(lambda: self.progress_label.config(text="Processing playlist..."))

            # Read output in real-time
            total_songs = 0
            current_song = 0
            line_count = 0
            for line in iter(process.stdout.readline, ''):
                if line:
                    self.safe_log_output(line)
                    line_clean = line.strip()
                    line_count += 1

                    # More robust parsing for total songs
                    if "Downloading" in line_clean and "tracks" in line_clean:
                        try:
                            # Look for patterns like "Downloading 5 tracks:"
                            words = line_clean.split()
                            for i, word in enumerate(words):
                                if word == "Downloading" and i + 1 < len(words):
                                    # Next word should be the number
                                    try:
                                        total_songs = int(words[i + 1])
                                        # Set up progress bar for determinate tracking
                                        self.safe_update_progress(0, total_songs, f"Found {total_songs} tracks")
                                        self.safe_gui_update(lambda: self.progress_label.config(text=f"Found {total_songs} tracks to download"))
                                        self.safe_update_status(f"Found {total_songs} tracks")
                                        break
                                    except (ValueError, IndexError):
                                        continue
                        except (ValueError, IndexError):
                            pass

                    # Also check the old pattern for compatibility
                    elif "Found" in line_clean and ("tracks" in line_clean or "songs" in line_clean):
                        try:
                            # Look for patterns like "Found 25 tracks" or "Found 25 songs"
                            words = line_clean.split()
                            for i, word in enumerate(words):
                                if word == "Found" and i + 1 < len(words):
                                    total_songs = int(words[i + 1])
                                    # Set up progress bar for determinate tracking
                                    self.safe_update_progress(0, total_songs, f"Found {total_songs} tracks")
                                    self.safe_gui_update(lambda: self.progress_label.config(text=f"Found {total_songs} tracks to download"))
                                    self.safe_update_status(f"Found {total_songs} tracks")
                                    break
                        except (ValueError, IndexError):
                            pass

                    # Enhanced progress parsing - multiple patterns
                    progress_updated = False

                    # Pattern 1: [current/total] format
                    if "[" in line_clean and "/" in line_clean and "]" in line_clean:
                        try:
                            start = line_clean.find("[") + 1
                            end = line_clean.find("]")
                            progress_str = line_clean[start:end]
                            if "/" in progress_str:
                                current, total = map(int, progress_str.split('/'))
                                current_song = current
                                if total > total_songs:
                                    total_songs = total
                                # Update progress bar
                                self.safe_update_progress(current_song, total_songs, f"Downloading song {current_song}/{total_songs}")
                                self.safe_update_status(f"Downloading song {current_song}/{total_songs}")
                                self.safe_gui_update(lambda: self.progress_label.config(text=f"Downloading song {current_song} of {total_songs}"))
                                progress_updated = True
                        except (ValueError, IndexError):
                            pass

                    # Pattern 2: "Downloading track X of Y" format
                    if not progress_updated and ("downloading" in line_clean.lower() or "processing" in line_clean.lower()):
                        try:
                            # Look for patterns like "Downloading track 5 of 25"
                            words = line_clean.lower().split()
                            for i, word in enumerate(words):
                                if word in ["track", "song"] and i + 1 < len(words) and i + 3 < len(words):
                                    if words[i + 2] == "of":
                                        current_song = int(words[i + 1])
                                        total_songs = int(words[i + 3])
                                        # Update progress bar
                                        self.safe_update_progress(current_song, total_songs, f"Downloading song {current_song}/{total_songs}")
                                        self.safe_update_status(f"Downloading song {current_song}/{total_songs}")
                                        self.safe_gui_update(lambda: self.progress_label.config(text=f"Downloading song {current_song} of {total_songs}"))
                                        progress_updated = True
                                        break
                        except (ValueError, IndexError):
                            pass

                    # Pattern 3: Simple numeric progress indicators
                    if not progress_updated:
                        try:
                            # Look for simple progress indicators like "5/25" anywhere in the line
                            import re
                            match = re.search(r'(\d+)/(\d+)', line_clean)
                            if match:
                                current = int(match.group(1))
                                total = int(match.group(2))
                                # Accept any reasonable progress ratio
                                if current <= total and total > 1 and current >= 0:
                                    current_song = current
                                    if total > total_songs or total_songs == 0:
                                        total_songs = total
                                    # Update progress bar
                                    self.safe_update_progress(current_song, total_songs, f"Processing {current_song}/{total_songs}")
                                    self.safe_update_status(f"Processing {current_song}/{total_songs}")
                                    self.safe_gui_update(lambda: self.progress_label.config(text=f"Processing {current_song} of {total_songs}"))
                                    progress_updated = True
                        except (ValueError, IndexError):
                            pass

                    # Pattern 4: Look for any completed downloads
                    if not progress_updated and ("Succeeded:" in line_clean or "downloaded" in line_clean.lower() or "completed" in line_clean.lower()):
                        # Try to extract completion info if available
                        try:
                            if total_songs > 0 and current_song < total_songs:
                                # Increment progress for each successful download
                                current_song += 1
                                self.safe_update_progress(current_song, total_songs, f"Completed {current_song}/{total_songs}")
                                self.safe_update_status(f"Downloaded {current_song}/{total_songs}")
                                self.safe_gui_update(lambda: self.progress_label.config(text=f"Downloaded {current_song} of {total_songs}"))
                                progress_updated = True
                        except:
                            pass

                    # Log debug info for troubleshooting
                    import re
                    if (("Downloading" in line_clean and "tracks" in line_clean) or
                        "Succeeded:" in line_clean or
                        re.search(r'\d+/\d+', line_clean) or
                        ("[" in line_clean and "]" in line_clean)):
                        self.safe_log_output(f"[DEBUG] Progress line: {line_clean}\n")

                    # Update GUI and status regardless
                    if progress_updated:
                        pass  # GUI updates are now handled by safe methods
                    else:
                        # If no specific progress found, still update status occasionally
                        if line_count % 20 == 0:  # Update status every 20 lines
                            self.safe_update_status(f"Processing... ({line_count} updates)")
                            if total_songs > 0:
                                self.safe_gui_update(lambda: self.progress_label.config(text=f"Working on {total_songs} tracks..."))
                            else:
                                self.safe_gui_update(lambda: self.progress_label.config(text=f"Processing... ({line_count} updates)"))

                    # Update GUI if any progress was made
                    if progress_updated:
                        pass  # GUI updates are now handled by safe methods

            # Wait for process to complete
            return_code = process.wait()

            # Stop any indeterminate progress and ensure we're in determinate mode
            self.ensure_determinate_mode()

            if return_code == 0:
                # Set progress to 100% on successful completion
                if self.progress['maximum'] > 0:
                    self.safe_update_progress(self.progress['maximum'], self.progress['maximum'], "Download completed")
                else:
                    self.safe_update_progress(100, 100, "Download completed")

                self.safe_log_output("\n" + "=" * 50 + "\n")
                self.safe_log_output("Download completed successfully!\n")

                self.safe_update_status("Processing results...")
                self.safe_gui_update(lambda: self.progress_label.config(text="Processing results..."))

                # Process the most recently created index CSV file
                download_dir = self.download_path_var.get().strip()
                if not download_dir or download_dir.startswith("e.g.,"):
                    download_dir = "."

                # Find the most recently modified _index.csv file in the directory tree
                most_recent_csv = self.find_most_recent_index_csv(download_dir)

                if most_recent_csv:
                    success = self.csv_processor.process_csv_file(str(most_recent_csv))
                    if success:
                        # Get the directory name for user feedback
                        playlist_dir = most_recent_csv.parent.name
                        self.safe_log_output(f"Processed sldl index file in '{playlist_dir}' directory with human-readable error codes.\n")
                    else:
                        self.safe_log_output("Failed to process sldl index file.\n")
                else:
                    self.safe_log_output("No sldl index file found to process.\n")

                self.safe_update_status("Download completed successfully")
                self.safe_gui_update(lambda: self.progress_label.config(text="Download completed successfully!"))
                messagebox.showinfo("Success", "Download completed successfully!")
            else:
                self.safe_log_output(f"\nProcess exited with code: {return_code}\n")
                self.safe_update_status(f"Download failed (exit code: {return_code})")
                self.safe_gui_update(lambda: self.progress_label.config(text=f"Download failed (exit code: {return_code})"))
                messagebox.showerror("Error", f"Download failed with exit code: {return_code}")

        except FileNotFoundError:
            error_msg = "sldl command not found. Please ensure slsk-batchdl is installed at /usr/local/bin/sldl"
            self.safe_log_output(f"Error: {error_msg}\n")
            self.safe_update_status("Error: sldl not found")
            self.safe_gui_update(lambda: self.progress_label.config(text="Error: sldl not found"))
            messagebox.showerror("Error", error_msg)
        except Exception as e:
            error_msg = f"Error during download: {e}"
            self.safe_log_output(f"Error: {error_msg}\n")
            self.safe_update_status("Error occurred")
            self.safe_gui_update(lambda: self.progress_label.config(text="Error occurred"))
            messagebox.showerror("Error", error_msg)
        finally:
            # Re-enable controls
            self.download_btn.config(state='normal')
            self.browse_btn.config(state='normal')

            # Reset progress only if not completed successfully
            if self.status_var.get() not in ["Download completed successfully"]:
                self.progress['value'] = 0
                self.safe_gui_update(lambda: self.progress_label.config(text="Ready to download"))
                if self.status_var.get().startswith("Error") or self.status_var.get().startswith("Download failed"):
                    pass  # Keep error status
                else:
                    self.safe_update_status("Ready")

            self.root.update_idletasks()

    def load_settings(self):
        """Load user settings from file and populate the UI."""
        try:
            if self.settings_file.exists():
                with open(self.settings_file, 'r') as f:
                    settings = json.load(f)

                # Load password persistence setting first
                if 'remember_password' in settings:
                    self.remember_password_var.set(settings['remember_password'])

                # Load credentials
                if 'username' in settings:
                    self.username_var.set(settings['username'])

                # Only load password if remember password was enabled
                if 'password' in settings and settings.get('remember_password', True):
                    # Decode the base64 encoded password
                    try:
                        decoded_password = base64.b64decode(settings['password']).decode('utf-8')
                        self.password_var.set(decoded_password)
                    except:
                        pass  # If decoding fails, leave password empty

                # Load download path
                if 'download_path' in settings:
                    self.download_path_var.set(settings['download_path'])

                # Load preferred settings
                if 'pref_format' in settings:
                    self.pref_format_var.set(settings['pref_format'])
                if 'pref_min_bitrate' in settings:
                    self.pref_min_bitrate_var.set(settings['pref_min_bitrate'])
                if 'pref_max_bitrate' in settings:
                    self.pref_max_bitrate_var.set(settings['pref_max_bitrate'])

                # Load strict settings
                if 'strict_format' in settings:
                    self.strict_format_var.set(settings['strict_format'])
                if 'strict_min_bitrate' in settings:
                    self.strict_min_bitrate_var.set(settings['strict_min_bitrate'])
                if 'strict_max_bitrate' in settings:
                    self.strict_max_bitrate_var.set(settings['strict_max_bitrate'])

                # Settings loaded silently
                pass
            else:
                # No saved settings - using defaults silently
                pass

        except Exception as e:
            self.safe_log_output(f"Error loading settings: {e}\n")

    def save_settings(self):
        """Save current user settings to file."""
        # Don't save during initial loading to prevent infinite loops
        if hasattr(self, 'loading_settings') and self.loading_settings:
            return

        try:
            settings = {
                'username': self.username_var.get().strip(),
                'download_path': self.download_path_var.get().strip(),
                'pref_format': self.pref_format_var.get(),
                'pref_min_bitrate': self.pref_min_bitrate_var.get().strip(),
                'pref_max_bitrate': self.pref_max_bitrate_var.get().strip(),
                'strict_format': self.strict_format_var.get(),
                'strict_min_bitrate': self.strict_min_bitrate_var.get().strip(),
                'strict_max_bitrate': self.strict_max_bitrate_var.get().strip(),
                'remember_password': self.remember_password_var.get()
            }

            # Only save password if remember password is enabled
            if hasattr(self, 'remember_password_var') and self.remember_password_var.get():
                password = self.password_var.get().strip()
                if password:
                    settings['password'] = base64.b64encode(password.encode('utf-8')).decode('utf-8')

            # Only save non-empty, non-placeholder values
            clean_settings = {}
            for key, value in settings.items():
                if key == 'remember_password':
                    clean_settings[key] = value  # Always save this boolean setting
                elif value and not str(value).startswith("e.g.,") and not str(value).startswith("https://www.youtube.com/playlist"):
                    clean_settings[key] = value

            with open(self.settings_file, 'w') as f:
                json.dump(clean_settings, f, indent=2)

        except Exception as e:
            self.safe_log_output(f"Error saving settings: {e}\n")

    def find_most_recent_index_csv(self, directory):
        """Find the most recently modified _index.csv file in the directory tree."""
        try:
            download_path = Path(directory)
            if not download_path.exists():
                return None

            # Find all _index.csv files in the directory tree
            index_files = []
            for csv_file in download_path.rglob("_index.csv"):
                if csv_file.is_file():
                    index_files.append(csv_file)

            if not index_files:
                return None

            # Return the most recently modified file
            most_recent = max(index_files, key=lambda f: f.stat().st_mtime)
            return most_recent

        except Exception as e:
            self.safe_log_output(f"Error finding most recent index file: {e}\n")
            return None

    def on_closing(self):
        """Handle application closing."""
        self.save_settings()
        self.root.destroy()

    def setup_gui_updates(self):
        """Set up thread-safe GUI updates using a queue"""
        def process_gui_updates():
            try:
                while True:
                    # Non-blocking check for updates
                    update_func, args, kwargs = self.gui_queue.get_nowait()
                    update_func(*args, **kwargs)
            except queue.Empty:
                pass
            finally:
                # Schedule next check
                self.root.after(50, process_gui_updates)  # Check every 50ms

        # Start the update processor
        self.root.after(50, process_gui_updates)

    def safe_gui_update(self, func, *args, **kwargs):
        """Schedule a GUI update to run on the main thread"""
        try:
            self.gui_queue.put((func, args, kwargs))
        except AttributeError:
            # Fallback: if queue not set up yet, run directly (during init)
            try:
                func(*args, **kwargs)
            except:
                pass

    def safe_log_output(self, message):
        """Thread-safe version of log_output"""
        def _update():
            self.output.insert(tk.END, message)
            self.output.see(tk.END)
        try:
            self.safe_gui_update(_update)
        except AttributeError:
            # Fallback: direct update if queue not ready
            try:
                _update()
            except:
                pass

    def safe_update_progress(self, current, total, description=""):
        """Thread-safe version of update_progress"""
        def _update():
            try:
                self.ensure_determinate_mode()
                self.progress['maximum'] = total
                self.progress['value'] = current

                # Debug logging
                if total > 0:
                    percentage = (current / total) * 100
                    self.output.insert(tk.END, f"[PROGRESS] Setting progress: {current}/{total} ({percentage:.1f}%) - {description}\n")
                    self.output.see(tk.END)
                else:
                    self.output.insert(tk.END, f"[PROGRESS] Invalid total: {current}/{total} - {description}\n")
                    self.output.see(tk.END)
            except Exception as e:
                self.output.insert(tk.END, f"[ERROR] Progress update failed: {e}\n")
                self.output.see(tk.END)
        try:
            self.safe_gui_update(_update)
        except AttributeError:
            # Fallback: direct update if queue not ready
            try:
                _update()
            except:
                pass

    def safe_update_status(self, status_text, progress_text=None):
        """Thread-safe status and progress label updates"""
        def _update():
            self.status_var.set(status_text)
            if progress_text:
                self.progress_label.config(text=progress_text)
        try:
            self.safe_gui_update(_update)
        except AttributeError:
            # Fallback: direct update if queue not ready
            try:
                _update()
            except:
                pass


def main():
    """Main function to run the application"""
    root = tk.Tk()

    # Set application icon if available
    try:
        # You can add an icon file here if you have one
        # root.iconbitmap('icon.ico')  # For Windows
        # root.iconbitmap('icon.xbm')  # For Unix/Linux
        pass
    except:
        pass

    app = SoulseekDownloader(root)

    # Center the window
    root.update_idletasks()
    x = (root.winfo_screenwidth() // 2) - (root.winfo_width() // 2)
    y = (root.winfo_screenheight() // 2) - (root.winfo_height() // 2)
    root.geometry(f"+{x}+{y}")

    # Start the application
    root.mainloop()


if __name__ == "__main__":
    main()