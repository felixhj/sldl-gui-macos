#!/usr/bin/env python3
"""
CSV Processor for SLDL GUI for macOS
Post-processes CSV files generated by slsk-batchdl to add human-readable error codes and state descriptions.
"""

import csv
import os
import sys
from pathlib import Path
from typing import Dict, List, Optional


class SLDLCSVProcessor:
    """Processes CSV files from slsk-batchdl to add human-readable error codes and states."""
    
    # State codes mapping (from slsk-batchdl source code Enums.cs)
    STATE_CODES = {
        0: "Initial",
        1: "Downloaded",
        2: "Failed",
        3: "AlreadyExists",
        4: "NotFoundLastTime"
    }
    
    # Failure reason codes mapping (from slsk-batchdl source code Enums.cs)
    FAILURE_CODES = {
        0: "None",
        1: "InvalidSearchString",
        2: "OutOfDownloadRetries",
        3: "NoSuitableFileFound",
        4: "AllDownloadsFailed",
        5: "Other"
    }
    
    def __init__(self):
        self.processed_files = []
    
    def get_state_description(self, state_code: int) -> str:
        """Convert numeric state code to human-readable description."""
        return self.STATE_CODES.get(state_code, f"Unknown State ({state_code})")
    
    def get_failure_description(self, failure_code: int) -> str:
        """Convert numeric failure code to human-readable description."""
        return self.FAILURE_CODES.get(failure_code, f"Unknown Failure ({failure_code})")
    
    def process_csv_file(self, input_file: str, output_file: Optional[str] = None) -> bool:
        """
        Process a CSV file and add human-readable columns.
        
        Args:
            input_file: Path to the input CSV file
            output_file: Path to the output CSV file (optional, defaults to input_file with '_processed' suffix)
        
        Returns:
            bool: True if processing was successful, False otherwise
        """
        try:
            input_path = Path(input_file)
            if not input_path.exists():
                print(f"Error: Input file '{input_file}' does not exist.")
                return False
            
            # Generate output filename to be 'log.csv' in the same directory
            if output_file is None:
                output_path = input_path.parent / 'log.csv'
            else:
                output_path = Path(output_file)
            
            # Read the input CSV
            rows = []
            with open(input_path, 'r', newline='', encoding='utf-8') as csvfile:
                reader = csv.DictReader(csvfile)
                fieldnames = list(reader.fieldnames) if reader.fieldnames else []
                
                # Add new columns for human-readable descriptions
                if 'state' in fieldnames and 'state_description' not in fieldnames:
                    fieldnames.append('state_description')
                if 'failurereason' in fieldnames and 'failure_description' not in fieldnames:
                    fieldnames.append('failure_description')
                
                # Process each row
                for row in reader:
                    # Add state description
                    if 'state' in row and row['state'].isdigit():
                        state_code = int(row['state'])
                        row['state_description'] = self.get_state_description(state_code)
                    
                    # Add failure description
                    if 'failurereason' in row and row['failurereason'].isdigit():
                        failure_code = int(row['failurereason'])
                        row['failure_description'] = self.get_failure_description(failure_code)
                    
                    rows.append(row)
            
            # Write the processed CSV
            with open(output_path, 'w', newline='', encoding='utf-8') as csvfile:
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                writer.writeheader()
                writer.writerows(rows)
            
            # Delete the original file after successful processing
            try:
                input_path.unlink()
                print(f"Successfully processed '{input_file}' -> '{output_path}' and deleted original file.")
            except OSError as e:
                print(f"Error deleting original file '{input_file}': {e}")

            self.processed_files.append(str(output_path))
            return True
            
        except Exception as e:
            print(f"Error processing '{input_file}': {e}")
            return False
    
    def process_directory(self, directory: str, pattern: str = "*.csv") -> List[str]:
        """
        Process all CSV files in a directory matching the pattern.
        
        Args:
            directory: Directory path to search for CSV files
            pattern: File pattern to match (default: "*.csv")
        
        Returns:
            List[str]: List of successfully processed file paths
        """
        processed_files = []
        dir_path = Path(directory)
        
        if not dir_path.exists() or not dir_path.is_dir():
            print(f"Error: Directory '{directory}' does not exist or is not a directory.")
            return processed_files
        
        # Find all CSV files
        csv_files = list(dir_path.glob(pattern))
        
        if not csv_files:
            print(f"No CSV files found in '{directory}' matching pattern '{pattern}'")
            return processed_files
        
        print(f"Found {len(csv_files)} CSV files to process...")
        
        for csv_file in csv_files:
            if self.process_csv_file(str(csv_file)):
                processed_files.append(str(csv_file))
        
        return processed_files
    
    def get_statistics(self) -> Dict[str, int]:
        """
        Get statistics about processed files and error codes.
        
        Returns:
            Dict containing statistics
        """
        stats = {
            'total_processed_files': len(self.processed_files),
            'state_codes_defined': len(self.STATE_CODES),
            'failure_codes_defined': len(self.FAILURE_CODES)
        }
        return stats


def main():
    """Main function for command-line usage."""
    if len(sys.argv) < 2:
        print("Usage:")
        print("  python csv_processor.py <input_file> [output_file]")
        print("  python csv_processor.py --directory <directory> [--pattern <pattern>]")
        print("  python csv_processor.py --help")
        return
    
    processor = SLDLCSVProcessor()
    
    if sys.argv[1] == "--help":
        print("CSV Processor for SLDL GUI for macOS")
        print("Post-processes CSV files from slsk-batchdl to add human-readable error codes.")
        print("\nUsage:")
        print("  python csv_processor.py <input_file> [output_file]")
        print("  python csv_processor.py --directory <directory> [--pattern <pattern>]")
        print("\nExamples:")
        print("  python csv_processor.py downloads.csv")
        print("  python csv_processor.py downloads.csv downloads_processed.csv")
        print("  python csv_processor.py --directory ./downloads")
        print("  python csv_processor.py --directory ./downloads --pattern '*_results.csv'")
        return
    
    if sys.argv[1] == "--directory":
        if len(sys.argv) < 3:
            print("Error: Directory path required")
            return
        
        directory = sys.argv[2]
        pattern = sys.argv[4] if len(sys.argv) > 4 and sys.argv[3] == "--pattern" else "*.csv"
        
        processed_files = processor.process_directory(directory, pattern)
        print(f"\nProcessed {len(processed_files)} files successfully.")
        
    else:
        input_file = sys.argv[1]
        output_file = sys.argv[2] if len(sys.argv) > 2 else None
        
        success = processor.process_csv_file(input_file, output_file)
        if success:
            print("File processed successfully.")
        else:
            print("Failed to process file.")
    
    # Print statistics
    stats = processor.get_statistics()
    print(f"\nStatistics:")
    print(f"  Total processed files: {stats['total_processed_files']}")
    print(f"  State codes defined: {stats['state_codes_defined']}")
    print(f"  Failure codes defined: {stats['failure_codes_defined']}")


if __name__ == "__main__":
    main() 